name: ''
content: "In preparation for TI-Concours, I picked up my TI-89t and tried to make a few programs with it. Among other things, I made a tilemap engine, so I thought I would share the code and explain the parts.\n\n  First, let's take a look at how indirection works. If you have an argument that requires a variable name, you can //indirectly// refer to it with a string. For example, you can draw a picture on the graph screen named sprite0 like this:\n[[code]]\n\"sprite0\"→string\nRclPic #string,0,0\n[[/code]]\nIn that example, 'string' had the variable name and we used the indirection symbol '#' to tell the program to use the string as the variable name. This will do the same thing:\n[[code]]\nRclPic sprite0,0,0\n[[/code]]\n\nIf you are familiar with the [[[68k:string()]]] command, then you are probably coming up with all sorts of ideas already. For example, say you had a bunch of sprites named sprite0,sprite1,sprite2,... and you wanted to draw a sprite based on an input number:\n[[code]]\n\"sprite\"&string(num)→string\nRclPic #string,0,0\n[[/code]]\nOr to optimise this a little:\n[[code]]\nRclPic #(\"sprite\"&string(num)),0,0\n[[/code]]\nNow if 'num' holds the sprite number to draw, it will draw the appropriate sprite. Using this, we can make a tilemap engine that uses a matrix to hold the tile numbers and uses 8x8 tiles:\n[[code]]\nFor a,1,8     ;8 tiles tall\nFor b,1,8     ;8 tiles wide\nRclPic #(\"sprite\"&string(tilemap[a,b])),shift(a,3),shift(b,3)\nEndFor\nEndFor\n[[/code]]\n@@tilemap[a,b]@@ is used to access each matrix element and shift(a,3) basically multiplies the value of a by 8. A more memory efficient way of storing tilemaps, though, is to use strings. For example, if you start your sprite index at sprite1 instead of sprite0, you can convert your matrix to 1-byte [[[68k:char()]]] strings and then add them all together. So the conversion code:\n[[code]]\n\"\"→str0\nFor a,1,8\nFor b,1,8\nstr0+char(tilemap[a,b])→str0\nEndFor\nEndFor\n[[/code]]\nThen to draw your tilemap, you can use the inverse function of char()-- [[[68k:ord()]]]:\n[[code]]\n0→c\nFor a,1,8\nFor b,1,8\nc+1→c\nRclPic #(\"sprite\"&string(ord(mid(str0,c,1)))),shift(a,3),shift(b,3)\nEndFor\nEndFor\n[[/code]]\nOr probably better:\n[[code]]\nFor a,0,63\nRclPic #(\"sprite\"&string(ord(mid(str0,a+1,1)))),8*int(a/8),8*mod(a,8)\nEndFor\n[[/code]]\n\nAttached is a screenshot taken using CalcCapture. I tested it and unfortunately, the screenshot is about half the speed that it actually runs at, so keep that in mind!\n[[image http://tibasicdev.wdfiles.com/local--files/file:tilemapex0/TileMapEx0.GIF]]\nThis program is a little different from the code that is posted in that it uses another level of indirection. It takes two inputs for the name of the tileset and the name of the tilemap, so it is meant to be a general tilemap engine."
attachment: 'file:tilemapex0/TileMapEx0.GIF'
