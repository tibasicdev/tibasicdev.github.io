[[include inc:68k-command
|picture=sum-sigma.png
|summary=Adds together the evaluations of an expression with one variable taking on a range of values.
|syntax=∑(//expression//, //variable//, //start//, //end//)

|location=
* Press 2nd MATH to enter the MATH popup menu.
* Press B to enter the Calculus submenu.
* Press 4 to select ∑(.

|size=2 bytes
]]

∑() is used to add a sequence of numbers. ∑(//expression//, //variable//, //start//, //end//) will evaluate //expression// for //variable//=//start//, then for //variable//=//start//+1, all the way through //variable//=//end//, and add up the results:

[[code]]
:∑(f(x),x,1,5)
           f(1)+f(2)+f(3)+f(4)+f(5)
:∑(x^2,x,1,5)
           55
[[/code]]

In this way, ∑() is no different from taking [[[68k:sum()]]] of a sequence generated by [[[68k:seq()]]]. However, ∑() can be used for more abstract calculations -- for instance, when //start// or //end// is an undefined variable, it will try to find the sum in terms of that variable. ∑() can also be used to sum an infinite series (just make the value of //end// infinity -- ∞). 

[[code]]
:∑(x^2,x,1,n)
           n*(n+1)*(2*n+1)/6           
:∑(2^-x,x,1,∞)
           1
[[/code]]

+ Optimization

It's a good idea to replace sum(seq( by ∑( whenever it occurs. The only difficulty arises if seq() uses its //step// argument, since ∑() doesn't have one. There are three options:
* Forget about using ∑() and just go with the sum(seq( alternative.
* Use a [[[68k:when()]]] expression (probably with [[[68k:mod()]]]) to select the entries you care about.
* Use a linear equation to transform values from 1 to N into the correct values with the step.

Here is an example of these approaches: 
[[code]]
:sum(seq(x^2,x,1,9,2))
[[/code]]
This calculates 1^^2^^+3^^2^^+5^^2^^+7^^2^^+9^^2^^.

[[code]]
:∑(when(mod(x,2)=1,x^2,0),x,1,9)
[[/code]]
The when() command selects only the odd numbers -- those with mod(x,2)=1 -- from 1 to 9.

[[code]]
:∑((2x-1)^2,x,1,5)
[[/code]]
The equation 2*x-1 transforms the numbers 1..5 into the odd numbers 1..9.

+ Related Commands

* [[[68k:seq()]]]
* [[[68k:sum()]]]
* [[[68k:product()]]]
* [[[68k:product-pi|∏()]]]