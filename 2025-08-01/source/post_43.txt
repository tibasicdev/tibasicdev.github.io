content: "I have started working on an application that will hopefully evolve to provide on-calc tutorials. Currently it has an example to show the user how to create a simple Hello World program. Here is a screenshot:\n[[image http://www.omnimaga.org/index.php?action=dlattach;topic=15662.0;attach=14627;image]]\nThe \"tutorials\" are basically a sequence of keypresses that get simulated. As well, I have added in some commands to interact with the user so you can actually step the user through the process and give them notifications about what is going on. Once I add in a menu, I will release the app and source so that others can create tutorials and submit them for the official release.\n\nMy goal is to cover all of the commands and I will probably need a separate version to work with mathprint. As well as all of the commands, there will be tutorials for different aspects of programming and it will be possible to have tutorials outside the app (probably as appvars). The current command available for making a tutorial are:\n[[code]]\n/=====================\\\n|    Key(val)         | 1 byte\n\=====================/\n  This is the main command. This tells the engine which key to\nsimulate. For example, to simulate [ENTER], use Key(skEnter).\n/=====================\\\n|    Delay(val)       | 2 bytes\n\=====================/\n  This sets the delay between simulated key presses. I find 30\nto work well.\n/=====================\\\n|    Text(y,x,string) | 4 bytes + length of string\n\=====================/\n  This is how you communicate to the user. This is like the\nBASIC command, except it draws over whatever is on the LCD, not\njust the graph screen. For the worried, this does not affect the\ncontents of the graph screen. So for example:\n     Text(56,0,\"Hello World!\")\n/=====================\\\n|    WaitForKey(key)  | 2 bytes\n\=====================/\n  This waits for the user to press the appropriate key. When the\nuser presses the key, it will be registered. No other keys\nrespond while waiting.\n/=====================\\\n|    Repeat(key,num)  | 3 bytes\n\=====================/\n  This will simulate a key press a number of times in a row.\nThis is useful for navigating menus to get to an item.\n/=====================\\\n|    ExitTutor()      | 1 byte\n\=====================/\n  This ends the tutorial and normal OS stuff resumes.\n\n  These commands should be enough for most tasks. However, if\nthere are more commands for the adventurous:\n/=====================\\\n|    SetAns(num)      |\n\=====================/\n  This will set the \"Ans\" variable to the specified value. Note\nthat this whole program works with 1-byte values, 0 to 255.\n/=====================\\\n|    TestAnsEqu(num)  |\n\=====================/\n  If 'Ans' is equal to 'num', then 'Ans' is set to 1, else it\nis set to 0.\n/=====================\\\n|    GetKey(num)      |\n\=====================/\n  Stores the user's keypress to Ans. This isn't as responsive\nas it could be, yet, but it works.\n/=============================\\\n|    JumpIfAnsEqu(num,label)  |  4 bytes\n\=============================/\n  This will jump to a label if Ans=num. Note that the label must\nbe on the same flash page.\n/=====================\\\n|    PushAns()        |\n\=====================/\n  This pushes Ans onto a stack for later retrieval with\nPopAns(). The stack is currently 240 bytes, but it may be\nsmaller in the future.\n/=====================\\\n|    PopAns()         |\n\=====================/\n  This removes the last value on the stack and stores it to\n'Ans'.\n[[/code]]\nHopefully I will make a lot of progress on this project, but I also have several other big projects that I am working on. I think that once menus are finished, the rest will be easy."
attachment: null
